"""
Main entry point for the AI companion loop.

This module exposes a CLI that can be used to monitor MLflow for failed or
underperforming runs, propose patches based on the failure taxonomy, apply
those patches and optionally re‑run only the impacted jobs.  The CLI is
designed to be run as a standalone script (``python -m companion.loop``)
and integrates with the other modules in the ``companion`` package.

The typical workflow is:

1. **Monitor**: Scan MLflow runs for failures or low scores using the
   configured thresholds.  This downloads relevant artifacts into a
   temporary location.
2. **Propose**: For a given run, analyse the artifacts, classify the root
   cause and build a patch plan using the failure taxonomy and patch
   policies (see :mod:`companion.classifier` and :mod:`companion.planner`).
3. **Apply**: Write the proposed changes (to config or code) into a
   staged branch/patch folder, run pre‑merge tests, and optionally tag
   the associated MLflow run.  Diffs are stored alongside the plan.
4. **Rerun**: Use the orchestrator to re‑run only the impacted jobs as
   determined by the plan’s impact analysis (see :mod:`companion.impact`).

All operations should be idempotent and safe to run multiple times.  By
default, operations run in dry‑run mode; use the ``--auto-apply`` flag
when invoking ``apply`` or ``rerun`` to automatically commit changes
without human approval.
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Optional

from . import mlflow_client
from . import classifier
from . import planner
from . import impact
from . import runners
from . import reporters

def monitor(since: str, objective: str, threshold: float) -> None:
    """Monitor MLflow for failed or underperforming runs.

    This function queries MLflow using the configured tracking URI for
    runs that have failed (e.g. returned ``-inf``) or have a final
    objective value below the given threshold.  It downloads run
    artifacts and writes a summary to standard output.

    Parameters
    ----------
    since: str
        Time range to look back, e.g. ``"3d"`` to look at runs from
        the last three days.  Parsed in :mod:`mlflow_client`.
    objective: str
        The name of the objective metric to examine (e.g. ``"OOS_MAR"``
        or ``"ERPT"``).
    threshold: float
        Minimum acceptable value for the objective.  Runs below this
        threshold are considered underperforming.
    """
    # Defer implementation to mlflow_client.  This stub will be filled
    # in Phase 8.  When implemented, it should call
    # mlflow_client.fetch_runs(...) and print a summary of problematic
    # runs.
    raise NotImplementedError("monitor function is a stub; implement in Phase 8")

def propose(run_id: str, config_path: Optional[Path] = None) -> None:
    """Analyse a single run and propose a patch plan.

    This function downloads the artifacts for the given ``run_id``,
    classifies the failure using :func:`classifier.classify`, and then
    invokes :func:`planner.make_plan` to produce a patch proposal.
    The resulting plan is printed to standard output and written to the
    ``patches`` folder.

    Parameters
    ----------
    run_id: str
        The MLflow run identifier to analyse.
    config_path: Optional[Path]
        Optional path to the companion configuration file.  If not
        provided, ``configs/companion.json`` is used relative to the
        project root.
    """
    # Implementation to be added: download artifacts, classify, plan.
    raise NotImplementedError("propose function is a stub; implement in Phase 8")

def apply(plan_path: Path, dry_run: bool = True, auto_apply: bool = False) -> None:
    """Apply a patch plan to the project.

    This function reads a plan file generated by :func:`propose` and
    carries out the specified changes.  It writes updated files to
    temporary locations first and then moves them into place if
    ``dry_run`` is False.  All diffs are printed and persisted to
    the plan metadata for review.

    Parameters
    ----------
    plan_path: Path
        Path to the JSON patch plan produced by :func:`propose`.
    dry_run: bool, default True
        If True, do not write any files; just show what would change.
    auto_apply: bool, default False
        If True and the plan is considered low risk (Tier A), skip
        interactive confirmation and apply automatically.
    """
    raise NotImplementedError("apply function is a stub; implement in Phase 8")

def rerun(plan_path: Path, max_workers: int = 1, dry_run: bool = True, auto_apply: bool = False) -> None:
    """Re‑run impacted jobs based on a patch plan.

    After a plan has been applied, only certain studies (strategy,
    symbol, timeframe combinations) may be affected.  This function
    determines the impacted jobs via :mod:`companion.impact` and then
    invokes :mod:`companion.runners` to start new tuning runs using the
    orchestrator CLI.  It supports concurrent workers and dry‑run mode.

    Parameters
    ----------
    plan_path: Path
        Path to the plan file produced by :func:`propose`.
    max_workers: int, default 1
        Maximum number of concurrent re‑runs.  Use a small number on
        Windows to avoid overwhelming the machine.
    dry_run: bool, default True
        If True, print the re‑run commands without executing them.
    auto_apply: bool, default False
        If True and the plan is low risk, skip interactive prompts.
    """
    raise NotImplementedError("rerun function is a stub; implement in Phase 8")

def status() -> None:
    """Print a summary of open plans and recent actions.

    This helper reads the ``patches`` folder and any internal logs
    maintained by the companion to display the current state of the
    maintenance process.  It can show which plans are pending, which
    have been applied, and the outcome of any re‑runs.
    """
    raise NotImplementedError("status function is a stub; implement in Phase 8")

def _build_parser() -> argparse.ArgumentParser:
    """Internal helper to build the CLI argument parser.

    Returns
    -------
    argparse.ArgumentParser
        The parser configured with subcommands for ``monitor``,
        ``propose``, ``apply``, ``rerun`` and ``status``.
    """
    parser = argparse.ArgumentParser(description="AI companion maintenance CLI")
    subparsers = parser.add_subparsers(dest="command", required=True)

    mon = subparsers.add_parser("monitor", help="Scan MLflow runs for problems")
    mon.add_argument("--since", default="1d", help="Look back period, e.g. 7d")
    mon.add_argument("--objective", default="OOS_MAR", help="Objective metric name")
    mon.add_argument("--threshold", type=float, default=0.0, help="Minimum acceptable objective value")

    prop = subparsers.add_parser("propose", help="Analyse a run and propose a patch plan")
    prop.add_argument("run_id", help="MLflow run ID to analyse")
    prop.add_argument("--config", type=Path, help="Path to companion configuration file")

    ap = subparsers.add_parser("apply", help="Apply a patch plan to the project")
    ap.add_argument("plan", type=Path, help="Path to the plan JSON file")
    ap.add_argument("--dry-run", action="store_true", default=True, help="Do not write files, just show changes")
    ap.add_argument("--auto-apply", action="store_true", help="Automatically apply low‑risk changes")

    rr = subparsers.add_parser("rerun", help="Re‑run jobs impacted by a plan")
    rr.add_argument("plan", type=Path, help="Path to the plan JSON file")
    rr.add_argument("--max-workers", type=int, default=1, help="Max concurrent workers for re‑runs")
    rr.add_argument("--dry-run", action="store_true", default=True, help="Do not execute, just print commands")
    rr.add_argument("--auto-apply", action="store_true", help="Automatically apply low‑risk changes")

    subparsers.add_parser("status", help="Show current companion status")

    return parser

def main(argv: Optional[list[str]] = None) -> None:
    """Entry point for the ``python -m companion.loop`` module.

    Parses arguments and dispatches to the appropriate function.

    Parameters
    ----------
    argv: Optional[list[str]]
        Optional list of command line arguments for testing.  If
        ``None``, ``sys.argv`` is used.
    """
    parser = _build_parser()
    args = parser.parse_args(argv)
    if args.command == "monitor":
        monitor(args.since, args.objective, args.threshold)
    elif args.command == "propose":
        propose(args.run_id, args.config)
    elif args.command == "apply":
        apply(args.plan, dry_run=args.dry_run, auto_apply=args.auto_apply)
    elif args.command == "rerun":
        rerun(args.plan, max_workers=args.max_workers, dry_run=args.dry_run, auto_apply=args.auto_apply)
    elif args.command == "status":
        status()
    else:
        parser.error(f"Unknown command: {args.command}")

if __name__ == "__main__":  # pragma: no cover
    main()
